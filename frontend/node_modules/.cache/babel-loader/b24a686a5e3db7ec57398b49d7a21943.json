{"ast":null,"code":"// Packaging/modules magic dance.\n(function (factory) {\n  var L;\n\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['leaflet'], factory);\n  } else if (typeof module !== 'undefined') {\n    // Node/CommonJS\n    L = require('leaflet');\n    module.exports = factory(L);\n  } else {\n    // Browser globals\n    if (typeof window.L === 'undefined') throw 'Leaflet must be loaded first';\n    factory(window.L);\n  }\n})(function (L) {\n  \"use strict\";\n\n  L.Polyline._flat = L.LineUtil.isFlat || L.Polyline._flat || function (latlngs) {\n    // true if it's a flat array of latlngs; false if nested\n    return !L.Util.isArray(latlngs[0]) || typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined';\n  };\n  /**\n   * @fileOverview Leaflet Geometry utilities for distances and linear referencing.\n   * @name L.GeometryUtil\n   */\n\n\n  L.GeometryUtil = L.extend(L.GeometryUtil || {}, {\n    /**\n        Shortcut function for planar distance between two {L.LatLng} at current zoom.\n         @tutorial distance-length\n         @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlngA geographical point A\n        @param {L.LatLng} latlngB geographical point B\n        @returns {Number} planar distance\n     */\n    distance: function distance(map, latlngA, latlngB) {\n      return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));\n    },\n\n    /**\n        Shortcut function for planar distance between a {L.LatLng} and a segment (A-B).\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @returns {Number} planar distance\n    */\n    distanceSegment: function distanceSegment(map, latlng, latlngA, latlngB) {\n      var p = map.latLngToLayerPoint(latlng),\n          p1 = map.latLngToLayerPoint(latlngA),\n          p2 = map.latLngToLayerPoint(latlngB);\n      return L.LineUtil.pointToSegmentDistance(p, p1, p2);\n    },\n\n    /**\n        Shortcut function for converting distance to readable distance.\n        @param {Number} distance distance to be converted\n        @param {String} unit 'metric' or 'imperial'\n        @returns {String} in yard or miles\n    */\n    readableDistance: function readableDistance(distance, unit) {\n      var isMetric = unit !== 'imperial',\n          distanceStr;\n\n      if (isMetric) {\n        // show metres when distance is < 1km, then show km\n        if (distance > 1000) {\n          distanceStr = (distance / 1000).toFixed(2) + ' km';\n        } else {\n          distanceStr = Math.ceil(distance) + ' m';\n        }\n      } else {\n        distance *= 1.09361;\n\n        if (distance > 1760) {\n          distanceStr = (distance / 1760).toFixed(2) + ' miles';\n        } else {\n          distanceStr = Math.ceil(distance) + ' yd';\n        }\n      }\n\n      return distanceStr;\n    },\n\n    /**\n        Returns true if the latlng belongs to segment A-B\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @param {?Number} [tolerance=0.2] tolerance to accept if latlng belongs really\n        @returns {boolean}\n     */\n    belongsSegment: function belongsSegment(latlng, latlngA, latlngB, tolerance) {\n      tolerance = tolerance === undefined ? 0.2 : tolerance;\n      var hypotenuse = latlngA.distanceTo(latlngB),\n          delta = latlngA.distanceTo(latlng) + latlng.distanceTo(latlngB) - hypotenuse;\n      return delta / hypotenuse < tolerance;\n    },\n\n    /**\n     * Returns total length of line\n     * @tutorial distance-length\n     *\n     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\n     * @returns {Number} Total length (pixels for Point, meters for LatLng)\n     */\n    length: function length(coords) {\n      var accumulated = L.GeometryUtil.accumulatedLengths(coords);\n      return accumulated.length > 0 ? accumulated[accumulated.length - 1] : 0;\n    },\n\n    /**\n     * Returns a list of accumulated length along a line.\n     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\n     * @returns {Array<Number>} Array of accumulated lengths (pixels for Point, meters for LatLng)\n     */\n    accumulatedLengths: function accumulatedLengths(coords) {\n      if (typeof coords.getLatLngs == 'function') {\n        coords = coords.getLatLngs();\n      }\n\n      if (coords.length === 0) return [];\n      var total = 0,\n          lengths = [0];\n\n      for (var i = 0, n = coords.length - 1; i < n; i++) {\n        total += coords[i].distanceTo(coords[i + 1]);\n        lengths.push(total);\n      }\n\n      return lengths;\n    },\n\n    /**\n        Returns the closest point of a {L.LatLng} on the segment (A-B)\n         @tutorial closest\n         @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @returns {L.LatLng} Closest geographical point\n    */\n    closestOnSegment: function closestOnSegment(map, latlng, latlngA, latlngB) {\n      var maxzoom = map.getMaxZoom();\n      if (maxzoom === Infinity) maxzoom = map.getZoom();\n      var p = map.project(latlng, maxzoom),\n          p1 = map.project(latlngA, maxzoom),\n          p2 = map.project(latlngB, maxzoom),\n          closest = L.LineUtil.closestPointOnSegment(p, p1, p2);\n      return map.unproject(closest, maxzoom);\n    },\n\n    /**\n        Returns the closest latlng on layer.\n         Accept nested arrays\n         @tutorial closest\n         @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.LatLng>|Array<Array<L.LatLng>>|L.PolyLine|L.Polygon} layer - Layer that contains the result\n        @param {L.LatLng} latlng - The position to search\n        @param {?boolean} [vertices=false] - Whether to restrict to path vertices.\n        @returns {L.LatLng} Closest geographical point or null if layer param is incorrect\n    */\n    closest: function closest(map, layer, latlng, vertices) {\n      var latlngs,\n          mindist = Infinity,\n          result = null,\n          i,\n          n,\n          distance,\n          subResult;\n\n      if (layer instanceof Array) {\n        // if layer is Array<Array<T>>\n        if (layer[0] instanceof Array && typeof layer[0][0] !== 'number') {\n          // if we have nested arrays, we calc the closest for each array\n          // recursive\n          for (i = 0; i < layer.length; i++) {\n            subResult = L.GeometryUtil.closest(map, layer[i], latlng, vertices);\n\n            if (subResult && subResult.distance < mindist) {\n              mindist = subResult.distance;\n              result = subResult;\n            }\n          }\n\n          return result;\n        } else if (layer[0] instanceof L.LatLng || typeof layer[0][0] === 'number' || typeof layer[0].lat === 'number') {\n          // we could have a latlng as [x,y] with x & y numbers or {lat, lng}\n          layer = L.polyline(layer);\n        } else {\n          return result;\n        }\n      } // if we don't have here a Polyline, that means layer is incorrect\n      // see https://github.com/makinacorpus/Leaflet.GeometryUtil/issues/23\n\n\n      if (!(layer instanceof L.Polyline)) return result; // deep copy of latlngs\n\n      latlngs = JSON.parse(JSON.stringify(layer.getLatLngs().slice(0))); // add the last segment for L.Polygon\n\n      if (layer instanceof L.Polygon) {\n        // add the last segment for each child that is a nested array\n        var addLastSegment = function addLastSegment(latlngs) {\n          if (L.Polyline._flat(latlngs)) {\n            latlngs.push(latlngs[0]);\n          } else {\n            for (var i = 0; i < latlngs.length; i++) {\n              addLastSegment(latlngs[i]);\n            }\n          }\n        };\n\n        addLastSegment(latlngs);\n      } // we have a multi polygon / multi polyline / polygon with holes\n      // use recursive to explore and return the good result\n\n\n      if (!L.Polyline._flat(latlngs)) {\n        for (i = 0; i < latlngs.length; i++) {\n          // if we are at the lower level, and if we have a L.Polygon, we add the last segment\n          subResult = L.GeometryUtil.closest(map, latlngs[i], latlng, vertices);\n\n          if (subResult.distance < mindist) {\n            mindist = subResult.distance;\n            result = subResult;\n          }\n        }\n\n        return result;\n      } else {\n        // Lookup vertices\n        if (vertices) {\n          for (i = 0, n = latlngs.length; i < n; i++) {\n            var ll = latlngs[i];\n            distance = L.GeometryUtil.distance(map, latlng, ll);\n\n            if (distance < mindist) {\n              mindist = distance;\n              result = ll;\n              result.distance = distance;\n            }\n          }\n\n          return result;\n        } // Keep the closest point of all segments\n\n\n        for (i = 0, n = latlngs.length; i < n - 1; i++) {\n          var latlngA = latlngs[i],\n              latlngB = latlngs[i + 1];\n          distance = L.GeometryUtil.distanceSegment(map, latlng, latlngA, latlngB);\n\n          if (distance <= mindist) {\n            mindist = distance;\n            result = L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\n            result.distance = distance;\n          }\n        }\n\n        return result;\n      }\n    },\n\n    /**\n        Returns the closest layer to latlng among a list of layers.\n         @tutorial closest\n         @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.ILayer>} layers Set of layers\n        @param {L.LatLng} latlng - The position to search\n        @returns {object} ``{layer, latlng, distance}`` or ``null`` if list is empty;\n    */\n    closestLayer: function closestLayer(map, layers, latlng) {\n      var mindist = Infinity,\n          result = null,\n          ll = null,\n          distance = Infinity;\n\n      for (var i = 0, n = layers.length; i < n; i++) {\n        var layer = layers[i];\n\n        if (layer instanceof L.LayerGroup) {\n          // recursive\n          var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);\n\n          if (subResult.distance < mindist) {\n            mindist = subResult.distance;\n            result = subResult;\n          }\n        } else {\n          // Single dimension, snap on points, else snap on closest\n          if (typeof layer.getLatLng == 'function') {\n            ll = layer.getLatLng();\n            distance = L.GeometryUtil.distance(map, latlng, ll);\n          } else {\n            ll = L.GeometryUtil.closest(map, layer, latlng);\n            if (ll) distance = ll.distance; // Can return null if layer has no points.\n          }\n\n          if (distance < mindist) {\n            mindist = distance;\n            result = {\n              layer: layer,\n              latlng: ll,\n              distance: distance\n            };\n          }\n        }\n      }\n\n      return result;\n    },\n\n    /**\n        Returns the n closest layers to latlng among a list of input layers.\n         @param {L.Map} map - Leaflet map to be used for this method\n        @param {Array<L.ILayer>} layers - Set of layers\n        @param {L.LatLng} latlng - The position to search\n        @param {?Number} [n=layers.length] - the expected number of output layers.\n        @returns {Array<object>} an array of objects ``{layer, latlng, distance}`` or ``null`` if the input is invalid (empty list or negative n)\n    */\n    nClosestLayers: function nClosestLayers(map, layers, latlng, n) {\n      n = typeof n === 'number' ? n : layers.length;\n\n      if (n < 1 || layers.length < 1) {\n        return null;\n      }\n\n      var results = [];\n      var distance, ll;\n\n      for (var i = 0, m = layers.length; i < m; i++) {\n        var layer = layers[i];\n\n        if (layer instanceof L.LayerGroup) {\n          // recursive\n          var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);\n          results.push(subResult);\n        } else {\n          // Single dimension, snap on points, else snap on closest\n          if (typeof layer.getLatLng == 'function') {\n            ll = layer.getLatLng();\n            distance = L.GeometryUtil.distance(map, latlng, ll);\n          } else {\n            ll = L.GeometryUtil.closest(map, layer, latlng);\n            if (ll) distance = ll.distance; // Can return null if layer has no points.\n          }\n\n          results.push({\n            layer: layer,\n            latlng: ll,\n            distance: distance\n          });\n        }\n      }\n\n      results.sort(function (a, b) {\n        return a.distance - b.distance;\n      });\n\n      if (results.length > n) {\n        return results.slice(0, n);\n      } else {\n        return results;\n      }\n    },\n\n    /**\n     * Returns all layers within a radius of the given position, in an ascending order of distance.\n       @param {L.Map} map Leaflet map to be used for this method\n       @param {Array<ILayer>} layers - A list of layers.\n       @param {L.LatLng} latlng - The position to search\n       @param {?Number} [radius=Infinity] - Search radius in pixels\n       @return {object[]} an array of objects including layer within the radius, closest latlng, and distance\n     */\n    layersWithin: function layersWithin(map, layers, latlng, radius) {\n      radius = typeof radius == 'number' ? radius : Infinity;\n      var results = [];\n      var ll = null;\n      var distance = 0;\n\n      for (var i = 0, n = layers.length; i < n; i++) {\n        var layer = layers[i];\n\n        if (typeof layer.getLatLng == 'function') {\n          ll = layer.getLatLng();\n          distance = L.GeometryUtil.distance(map, latlng, ll);\n        } else {\n          ll = L.GeometryUtil.closest(map, layer, latlng);\n          if (ll) distance = ll.distance; // Can return null if layer has no points.\n        }\n\n        if (ll && distance < radius) {\n          results.push({\n            layer: layer,\n            latlng: ll,\n            distance: distance\n          });\n        }\n      }\n\n      var sortedResults = results.sort(function (a, b) {\n        return a.distance - b.distance;\n      });\n      return sortedResults;\n    },\n\n    /**\n        Returns the closest position from specified {LatLng} among specified layers,\n        with a maximum tolerance in pixels, providing snapping behaviour.\n         @tutorial closest\n         @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<ILayer>} layers - A list of layers to snap on.\n        @param {L.LatLng} latlng - The position to snap\n        @param {?Number} [tolerance=Infinity] - Maximum number of pixels.\n        @param {?boolean} [withVertices=true] - Snap to layers vertices or segment points (not only vertex)\n        @returns {object} with snapped {LatLng} and snapped {Layer} or null if tolerance exceeded.\n    */\n    closestLayerSnap: function closestLayerSnap(map, layers, latlng, tolerance, withVertices) {\n      tolerance = typeof tolerance == 'number' ? tolerance : Infinity;\n      withVertices = typeof withVertices == 'boolean' ? withVertices : true;\n      var result = L.GeometryUtil.closestLayer(map, layers, latlng);\n      if (!result || result.distance > tolerance) return null; // If snapped layer is linear, try to snap on vertices (extremities and middle points)\n\n      if (withVertices && typeof result.layer.getLatLngs == 'function') {\n        var closest = L.GeometryUtil.closest(map, result.layer, result.latlng, true);\n\n        if (closest.distance < tolerance) {\n          result.latlng = closest;\n          result.distance = L.GeometryUtil.distance(map, closest, latlng);\n        }\n      }\n\n      return result;\n    },\n\n    /**\n        Returns the Point located on a segment at the specified ratio of the segment length.\n        @param {L.Point} pA coordinates of point A\n        @param {L.Point} pB coordinates of point B\n        @param {Number} the length ratio, expressed as a decimal between 0 and 1, inclusive.\n        @returns {L.Point} the interpolated point.\n    */\n    interpolateOnPointSegment: function interpolateOnPointSegment(pA, pB, ratio) {\n      return L.point(pA.x * (1 - ratio) + ratio * pB.x, pA.y * (1 - ratio) + ratio * pB.y);\n    },\n\n    /**\n        Returns the coordinate of the point located on a line at the specified ratio of the line length.\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.LatLng>|L.PolyLine} latlngs Set of geographical points\n        @param {Number} ratio the length ratio, expressed as a decimal between 0 and 1, inclusive\n        @returns {Object} an object with latLng ({LatLng}) and predecessor ({Number}), the index of the preceding vertex in the Polyline\n        (-1 if the interpolated point is the first vertex)\n    */\n    interpolateOnLine: function interpolateOnLine(map, latLngs, ratio) {\n      latLngs = latLngs instanceof L.Polyline ? latLngs.getLatLngs() : latLngs;\n      var n = latLngs.length;\n\n      if (n < 2) {\n        return null;\n      } // ensure the ratio is between 0 and 1;\n\n\n      ratio = Math.max(Math.min(ratio, 1), 0);\n\n      if (ratio === 0) {\n        return {\n          latLng: latLngs[0] instanceof L.LatLng ? latLngs[0] : L.latLng(latLngs[0]),\n          predecessor: -1\n        };\n      }\n\n      if (ratio == 1) {\n        return {\n          latLng: latLngs[latLngs.length - 1] instanceof L.LatLng ? latLngs[latLngs.length - 1] : L.latLng(latLngs[latLngs.length - 1]),\n          predecessor: latLngs.length - 2\n        };\n      } // project the LatLngs as Points,\n      // and compute total planar length of the line at max precision\n\n\n      var maxzoom = map.getMaxZoom();\n      if (maxzoom === Infinity) maxzoom = map.getZoom();\n      var pts = [];\n      var lineLength = 0;\n\n      for (var i = 0; i < n; i++) {\n        pts[i] = map.project(latLngs[i], maxzoom);\n        if (i > 0) lineLength += pts[i - 1].distanceTo(pts[i]);\n      }\n\n      var ratioDist = lineLength * ratio; // follow the line segments [ab], adding lengths,\n      // until we find the segment where the points should lie on\n\n      var cumulativeDistanceToA = 0,\n          cumulativeDistanceToB = 0;\n\n      for (var i = 0; cumulativeDistanceToB < ratioDist; i++) {\n        var pointA = pts[i],\n            pointB = pts[i + 1];\n        cumulativeDistanceToA = cumulativeDistanceToB;\n        cumulativeDistanceToB += pointA.distanceTo(pointB);\n      }\n\n      if (pointA == undefined && pointB == undefined) {\n        // Happens when line has no length\n        var pointA = pts[0],\n            pointB = pts[1],\n            i = 1;\n      } // compute the ratio relative to the segment [ab]\n\n\n      var segmentRatio = cumulativeDistanceToB - cumulativeDistanceToA !== 0 ? (ratioDist - cumulativeDistanceToA) / (cumulativeDistanceToB - cumulativeDistanceToA) : 0;\n      var interpolatedPoint = L.GeometryUtil.interpolateOnPointSegment(pointA, pointB, segmentRatio);\n      return {\n        latLng: map.unproject(interpolatedPoint, maxzoom),\n        predecessor: i - 1\n      };\n    },\n\n    /**\n        Returns a float between 0 and 1 representing the location of the\n        closest point on polyline to the given latlng, as a fraction of total line length.\n        (opposite of L.GeometryUtil.interpolateOnLine())\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.PolyLine} polyline Polyline on which the latlng will be search\n        @param {L.LatLng} latlng The position to search\n        @returns {Number} Float between 0 and 1\n    */\n    locateOnLine: function locateOnLine(map, polyline, latlng) {\n      var latlngs = polyline.getLatLngs();\n      if (latlng.equals(latlngs[0])) return 0.0;\n      if (latlng.equals(latlngs[latlngs.length - 1])) return 1.0;\n      var point = L.GeometryUtil.closest(map, polyline, latlng, false),\n          lengths = L.GeometryUtil.accumulatedLengths(latlngs),\n          total_length = lengths[lengths.length - 1],\n          portion = 0,\n          found = false;\n\n      for (var i = 0, n = latlngs.length - 1; i < n; i++) {\n        var l1 = latlngs[i],\n            l2 = latlngs[i + 1];\n        portion = lengths[i];\n\n        if (L.GeometryUtil.belongsSegment(point, l1, l2, 0.001)) {\n          portion += l1.distanceTo(point);\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        throw \"Could not interpolate \" + latlng.toString() + \" within \" + polyline.toString();\n      }\n\n      return portion / total_length;\n    },\n\n    /**\n        Returns a clone with reversed coordinates.\n        @param {L.PolyLine} polyline polyline to reverse\n        @returns {L.PolyLine} polyline reversed\n    */\n    reverse: function reverse(polyline) {\n      return L.polyline(polyline.getLatLngs().slice(0).reverse());\n    },\n\n    /**\n        Returns a sub-part of the polyline, from start to end.\n        If start is superior to end, returns extraction from inverted line.\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.PolyLine} polyline Polyline on which will be extracted the sub-part\n        @param {Number} start ratio, expressed as a decimal between 0 and 1, inclusive\n        @param {Number} end ratio, expressed as a decimal between 0 and 1, inclusive\n        @returns {Array<L.LatLng>} new polyline\n     */\n    extract: function extract(map, polyline, start, end) {\n      if (start > end) {\n        return L.GeometryUtil.extract(map, L.GeometryUtil.reverse(polyline), 1.0 - start, 1.0 - end);\n      } // Bound start and end to [0-1]\n\n\n      start = Math.max(Math.min(start, 1), 0);\n      end = Math.max(Math.min(end, 1), 0);\n      var latlngs = polyline.getLatLngs(),\n          startpoint = L.GeometryUtil.interpolateOnLine(map, polyline, start),\n          endpoint = L.GeometryUtil.interpolateOnLine(map, polyline, end); // Return single point if start == end\n\n      if (start == end) {\n        var point = L.GeometryUtil.interpolateOnLine(map, polyline, end);\n        return [point.latLng];\n      } // Array.slice() works indexes at 0\n\n\n      if (startpoint.predecessor == -1) startpoint.predecessor = 0;\n      if (endpoint.predecessor == -1) endpoint.predecessor = 0;\n      var result = latlngs.slice(startpoint.predecessor + 1, endpoint.predecessor + 1);\n      result.unshift(startpoint.latLng);\n      result.push(endpoint.latLng);\n      return result;\n    },\n\n    /**\n        Returns true if first polyline ends where other second starts.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    isBefore: function isBefore(polyline, other) {\n      if (!other) return false;\n      var lla = polyline.getLatLngs(),\n          llb = other.getLatLngs();\n      return lla[lla.length - 1].equals(llb[0]);\n    },\n\n    /**\n        Returns true if first polyline starts where second ends.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    isAfter: function isAfter(polyline, other) {\n      if (!other) return false;\n      var lla = polyline.getLatLngs(),\n          llb = other.getLatLngs();\n      return lla[0].equals(llb[llb.length - 1]);\n    },\n\n    /**\n        Returns true if first polyline starts where second ends or start.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    startsAtExtremity: function startsAtExtremity(polyline, other) {\n      if (!other) return false;\n      var lla = polyline.getLatLngs(),\n          llb = other.getLatLngs(),\n          start = lla[0];\n      return start.equals(llb[0]) || start.equals(llb[llb.length - 1]);\n    },\n\n    /**\n        Returns horizontal angle in degres between two points.\n        @param {L.Point} a Coordinates of point A\n        @param {L.Point} b Coordinates of point B\n        @returns {Number} horizontal angle\n     */\n    computeAngle: function computeAngle(a, b) {\n      return Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI;\n    },\n\n    /**\n       Returns slope (Ax+B) between two points.\n        @param {L.Point} a Coordinates of point A\n        @param {L.Point} b Coordinates of point B\n        @returns {Object} with ``a`` and ``b`` properties.\n     */\n    computeSlope: function computeSlope(a, b) {\n      var s = (b.y - a.y) / (b.x - a.x),\n          o = a.y - s * a.x;\n      return {\n        'a': s,\n        'b': o\n      };\n    },\n\n    /**\n       Returns LatLng of rotated point around specified LatLng center.\n        @param {L.LatLng} latlngPoint: point to rotate\n        @param {double} angleDeg: angle to rotate in degrees\n        @param {L.LatLng} latlngCenter: center of rotation\n        @returns {L.LatLng} rotated point\n     */\n    rotatePoint: function rotatePoint(map, latlngPoint, angleDeg, latlngCenter) {\n      var maxzoom = map.getMaxZoom();\n      if (maxzoom === Infinity) maxzoom = map.getZoom();\n      var angleRad = angleDeg * Math.PI / 180,\n          pPoint = map.project(latlngPoint, maxzoom),\n          pCenter = map.project(latlngCenter, maxzoom),\n          x2 = Math.cos(angleRad) * (pPoint.x - pCenter.x) - Math.sin(angleRad) * (pPoint.y - pCenter.y) + pCenter.x,\n          y2 = Math.sin(angleRad) * (pPoint.x - pCenter.x) + Math.cos(angleRad) * (pPoint.y - pCenter.y) + pCenter.y;\n      return map.unproject(new L.Point(x2, y2), maxzoom);\n    },\n\n    /**\n       Returns the bearing in degrees clockwise from north (0 degrees)\n       from the first L.LatLng to the second, at the first LatLng\n       @param {L.LatLng} latlng1: origin point of the bearing\n       @param {L.LatLng} latlng2: destination point of the bearing\n       @returns {float} degrees clockwise from north.\n    */\n    bearing: function bearing(latlng1, latlng2) {\n      var rad = Math.PI / 180,\n          lat1 = latlng1.lat * rad,\n          lat2 = latlng2.lat * rad,\n          lon1 = latlng1.lng * rad,\n          lon2 = latlng2.lng * rad,\n          y = Math.sin(lon2 - lon1) * Math.cos(lat2),\n          x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n      var bearing = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;\n      return bearing >= 180 ? bearing - 360 : bearing;\n    },\n\n    /**\n       Returns the point that is a distance and heading away from\n       the given origin point.\n       @param {L.LatLng} latlng: origin point\n       @param {float} heading: heading in degrees, clockwise from 0 degrees north.\n       @param {float} distance: distance in meters\n       @returns {L.latLng} the destination point.\n       Many thanks to Chris Veness at http://www.movable-type.co.uk/scripts/latlong.html\n       for a great reference and examples.\n    */\n    destination: function destination(latlng, heading, distance) {\n      heading = (heading + 360) % 360;\n      var rad = Math.PI / 180,\n          radInv = 180 / Math.PI,\n          R = 6378137,\n          // approximation of Earth's radius\n      lon1 = latlng.lng * rad,\n          lat1 = latlng.lat * rad,\n          rheading = heading * rad,\n          sinLat1 = Math.sin(lat1),\n          cosLat1 = Math.cos(lat1),\n          cosDistR = Math.cos(distance / R),\n          sinDistR = Math.sin(distance / R),\n          lat2 = Math.asin(sinLat1 * cosDistR + cosLat1 * sinDistR * Math.cos(rheading)),\n          lon2 = lon1 + Math.atan2(Math.sin(rheading) * sinDistR * cosLat1, cosDistR - sinLat1 * Math.sin(lat2));\n      lon2 = lon2 * radInv;\n      lon2 = lon2 > 180 ? lon2 - 360 : lon2 < -180 ? lon2 + 360 : lon2;\n      return L.latLng([lat2 * radInv, lon2]);\n    },\n\n    /**\n       Returns the the angle of the given segment and the Equator in degrees,\n       clockwise from 0 degrees north.\n       @param {L.Map} map: Leaflet map to be used for this method\n       @param {L.LatLng} latlngA: geographical point A of the segment\n       @param {L.LatLng} latlngB: geographical point B of the segment\n       @returns {Float} the angle in degrees.\n    */\n    angle: function angle(map, latlngA, latlngB) {\n      var pointA = map.latLngToContainerPoint(latlngA),\n          pointB = map.latLngToContainerPoint(latlngB),\n          angleDeg = Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI + 90;\n      angleDeg += angleDeg < 0 ? 360 : 0;\n      return angleDeg;\n    },\n\n    /**\n       Returns a point snaps on the segment and heading away from the given origin point a distance.\n       @param {L.Map} map: Leaflet map to be used for this method\n       @param {L.LatLng} latlngA: geographical point A of the segment\n       @param {L.LatLng} latlngB: geographical point B of the segment\n       @param {float} distance: distance in meters\n       @returns {L.latLng} the destination point.\n    */\n    destinationOnSegment: function destinationOnSegment(map, latlngA, latlngB, distance) {\n      var angleDeg = L.GeometryUtil.angle(map, latlngA, latlngB),\n          latlng = L.GeometryUtil.destination(latlngA, angleDeg, distance);\n      return L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\n    }\n  });\n  return L.GeometryUtil;\n});","map":{"version":3,"sources":["/home/kuba/konkurs/front/rocket/node_modules/leaflet-geometryutil/src/leaflet.geometryutil.js"],"names":["factory","L","define","amd","module","require","exports","window","Polyline","_flat","LineUtil","isFlat","latlngs","Util","isArray","GeometryUtil","extend","distance","map","latlngA","latlngB","latLngToLayerPoint","distanceTo","distanceSegment","latlng","p","p1","p2","pointToSegmentDistance","readableDistance","unit","isMetric","distanceStr","toFixed","Math","ceil","belongsSegment","tolerance","undefined","hypotenuse","delta","length","coords","accumulated","accumulatedLengths","getLatLngs","total","lengths","i","n","push","closestOnSegment","maxzoom","getMaxZoom","Infinity","getZoom","project","closest","closestPointOnSegment","unproject","layer","vertices","mindist","result","subResult","Array","LatLng","lat","polyline","JSON","parse","stringify","slice","Polygon","addLastSegment","ll","closestLayer","layers","LayerGroup","getLayers","getLatLng","nClosestLayers","results","m","sort","a","b","layersWithin","radius","sortedResults","closestLayerSnap","withVertices","interpolateOnPointSegment","pA","pB","ratio","point","x","y","interpolateOnLine","latLngs","max","min","latLng","predecessor","pts","lineLength","ratioDist","cumulativeDistanceToA","cumulativeDistanceToB","pointA","pointB","segmentRatio","interpolatedPoint","locateOnLine","equals","total_length","portion","found","l1","l2","toString","reverse","extract","start","end","startpoint","endpoint","unshift","isBefore","other","lla","llb","isAfter","startsAtExtremity","computeAngle","atan2","PI","computeSlope","s","o","rotatePoint","latlngPoint","angleDeg","latlngCenter","angleRad","pPoint","pCenter","x2","cos","sin","y2","Point","bearing","latlng1","latlng2","rad","lat1","lat2","lon1","lng","lon2","destination","heading","radInv","R","rheading","sinLat1","cosLat1","cosDistR","sinDistR","asin","angle","latLngToContainerPoint","destinationOnSegment"],"mappings":"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","sourcesContent":["// Packaging/modules magic dance.\n(function (factory) {\n    var L;\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(['leaflet'], factory);\n    } else if (typeof module !== 'undefined') {\n        // Node/CommonJS\n        L = require('leaflet');\n        module.exports = factory(L);\n    } else {\n        // Browser globals\n        if (typeof window.L === 'undefined')\n            throw 'Leaflet must be loaded first';\n        factory(window.L);\n    }\n}(function (L) {\n\"use strict\";\n\nL.Polyline._flat = L.LineUtil.isFlat || L.Polyline._flat || function (latlngs) {\n    // true if it's a flat array of latlngs; false if nested\n    return !L.Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');\n};\n\n/**\n * @fileOverview Leaflet Geometry utilities for distances and linear referencing.\n * @name L.GeometryUtil\n */\n\nL.GeometryUtil = L.extend(L.GeometryUtil || {}, {\n\n    /**\n        Shortcut function for planar distance between two {L.LatLng} at current zoom.\n\n        @tutorial distance-length\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlngA geographical point A\n        @param {L.LatLng} latlngB geographical point B\n        @returns {Number} planar distance\n     */\n    distance: function (map, latlngA, latlngB) {\n        return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));\n    },\n\n    /**\n        Shortcut function for planar distance between a {L.LatLng} and a segment (A-B).\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @returns {Number} planar distance\n    */\n    distanceSegment: function (map, latlng, latlngA, latlngB) {\n        var p = map.latLngToLayerPoint(latlng),\n           p1 = map.latLngToLayerPoint(latlngA),\n           p2 = map.latLngToLayerPoint(latlngB);\n        return L.LineUtil.pointToSegmentDistance(p, p1, p2);\n    },\n\n    /**\n        Shortcut function for converting distance to readable distance.\n        @param {Number} distance distance to be converted\n        @param {String} unit 'metric' or 'imperial'\n        @returns {String} in yard or miles\n    */\n    readableDistance: function (distance, unit) {\n        var isMetric = (unit !== 'imperial'),\n            distanceStr;\n        if (isMetric) {\n            // show metres when distance is < 1km, then show km\n            if (distance > 1000) {\n                distanceStr = (distance  / 1000).toFixed(2) + ' km';\n            }\n            else {\n                distanceStr = Math.ceil(distance) + ' m';\n            }\n        }\n        else {\n            distance *= 1.09361;\n            if (distance > 1760) {\n                distanceStr = (distance / 1760).toFixed(2) + ' miles';\n            }\n            else {\n                distanceStr = Math.ceil(distance) + ' yd';\n            }\n        }\n        return distanceStr;\n    },\n\n    /**\n        Returns true if the latlng belongs to segment A-B\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @param {?Number} [tolerance=0.2] tolerance to accept if latlng belongs really\n        @returns {boolean}\n     */\n    belongsSegment: function(latlng, latlngA, latlngB, tolerance) {\n        tolerance = tolerance === undefined ? 0.2 : tolerance;\n        var hypotenuse = latlngA.distanceTo(latlngB),\n            delta = latlngA.distanceTo(latlng) + latlng.distanceTo(latlngB) - hypotenuse;\n        return delta/hypotenuse < tolerance;\n    },\n\n    /**\n     * Returns total length of line\n     * @tutorial distance-length\n     *\n     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\n     * @returns {Number} Total length (pixels for Point, meters for LatLng)\n     */\n    length: function (coords) {\n        var accumulated = L.GeometryUtil.accumulatedLengths(coords);\n        return accumulated.length > 0 ? accumulated[accumulated.length-1] : 0;\n    },\n\n    /**\n     * Returns a list of accumulated length along a line.\n     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\n     * @returns {Array<Number>} Array of accumulated lengths (pixels for Point, meters for LatLng)\n     */\n    accumulatedLengths: function (coords) {\n        if (typeof coords.getLatLngs == 'function') {\n            coords = coords.getLatLngs();\n        }\n        if (coords.length === 0)\n            return [];\n        var total = 0,\n            lengths = [0];\n        for (var i = 0, n = coords.length - 1; i< n; i++) {\n            total += coords[i].distanceTo(coords[i+1]);\n            lengths.push(total);\n        }\n        return lengths;\n    },\n\n    /**\n        Returns the closest point of a {L.LatLng} on the segment (A-B)\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @returns {L.LatLng} Closest geographical point\n    */\n    closestOnSegment: function (map, latlng, latlngA, latlngB) {\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity)\n            maxzoom = map.getZoom();\n        var p = map.project(latlng, maxzoom),\n           p1 = map.project(latlngA, maxzoom),\n           p2 = map.project(latlngB, maxzoom),\n           closest = L.LineUtil.closestPointOnSegment(p, p1, p2);\n        return map.unproject(closest, maxzoom);\n    },\n\n    /**\n        Returns the closest latlng on layer.\n\n        Accept nested arrays\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.LatLng>|Array<Array<L.LatLng>>|L.PolyLine|L.Polygon} layer - Layer that contains the result\n        @param {L.LatLng} latlng - The position to search\n        @param {?boolean} [vertices=false] - Whether to restrict to path vertices.\n        @returns {L.LatLng} Closest geographical point or null if layer param is incorrect\n    */\n    closest: function (map, layer, latlng, vertices) {\n\n        var latlngs,\n            mindist = Infinity,\n            result = null,\n            i, n, distance, subResult;\n\n        if (layer instanceof Array) {\n            // if layer is Array<Array<T>>\n            if (layer[0] instanceof Array && typeof layer[0][0] !== 'number') {\n                // if we have nested arrays, we calc the closest for each array\n                // recursive\n                for (i = 0; i < layer.length; i++) {\n                    subResult = L.GeometryUtil.closest(map, layer[i], latlng, vertices);\n                    if (subResult && subResult.distance < mindist) {\n                        mindist = subResult.distance;\n                        result = subResult;\n                    }\n                }\n                return result;\n            } else if (layer[0] instanceof L.LatLng\n                        || typeof layer[0][0] === 'number'\n                        || typeof layer[0].lat === 'number') { // we could have a latlng as [x,y] with x & y numbers or {lat, lng}\n                layer = L.polyline(layer);\n            } else {\n                return result;\n            }\n        }\n\n        // if we don't have here a Polyline, that means layer is incorrect\n        // see https://github.com/makinacorpus/Leaflet.GeometryUtil/issues/23\n        if (! ( layer instanceof L.Polyline ) )\n            return result;\n\n        // deep copy of latlngs\n        latlngs = JSON.parse(JSON.stringify(layer.getLatLngs().slice(0)));\n\n        // add the last segment for L.Polygon\n        if (layer instanceof L.Polygon) {\n            // add the last segment for each child that is a nested array\n            var addLastSegment = function(latlngs) {\n                if (L.Polyline._flat(latlngs)) {\n                    latlngs.push(latlngs[0]);\n                } else {\n                    for (var i = 0; i < latlngs.length; i++) {\n                        addLastSegment(latlngs[i]);\n                    }\n                }\n            };\n            addLastSegment(latlngs);\n        }\n\n        // we have a multi polygon / multi polyline / polygon with holes\n        // use recursive to explore and return the good result\n        if ( ! L.Polyline._flat(latlngs) ) {\n            for (i = 0; i < latlngs.length; i++) {\n                // if we are at the lower level, and if we have a L.Polygon, we add the last segment\n                subResult = L.GeometryUtil.closest(map, latlngs[i], latlng, vertices);\n                if (subResult.distance < mindist) {\n                    mindist = subResult.distance;\n                    result = subResult;\n                }\n            }\n            return result;\n\n        } else {\n\n            // Lookup vertices\n            if (vertices) {\n                for(i = 0, n = latlngs.length; i < n; i++) {\n                    var ll = latlngs[i];\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                    if (distance < mindist) {\n                        mindist = distance;\n                        result = ll;\n                        result.distance = distance;\n                    }\n                }\n                return result;\n            }\n\n            // Keep the closest point of all segments\n            for (i = 0, n = latlngs.length; i < n-1; i++) {\n                var latlngA = latlngs[i],\n                    latlngB = latlngs[i+1];\n                distance = L.GeometryUtil.distanceSegment(map, latlng, latlngA, latlngB);\n                if (distance <= mindist) {\n                    mindist = distance;\n                    result = L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\n                    result.distance = distance;\n                }\n            }\n            return result;\n        }\n\n    },\n\n    /**\n        Returns the closest layer to latlng among a list of layers.\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.ILayer>} layers Set of layers\n        @param {L.LatLng} latlng - The position to search\n        @returns {object} ``{layer, latlng, distance}`` or ``null`` if list is empty;\n    */\n    closestLayer: function (map, layers, latlng) {\n        var mindist = Infinity,\n            result = null,\n            ll = null,\n            distance = Infinity;\n\n        for (var i = 0, n = layers.length; i < n; i++) {\n            var layer = layers[i];\n            if (layer instanceof L.LayerGroup) {\n                // recursive\n                var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);\n                if (subResult.distance < mindist) {\n                    mindist = subResult.distance;\n                    result = subResult;\n                }\n            } else {\n                // Single dimension, snap on points, else snap on closest\n                if (typeof layer.getLatLng == 'function') {\n                    ll = layer.getLatLng();\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                }\n                else {\n                    ll = L.GeometryUtil.closest(map, layer, latlng);\n                    if (ll) distance = ll.distance;  // Can return null if layer has no points.\n                }\n                if (distance < mindist) {\n                    mindist = distance;\n                    result = {layer: layer, latlng: ll, distance: distance};\n                }\n            }\n        }\n        return result;\n    },\n\n    /**\n        Returns the n closest layers to latlng among a list of input layers.\n\n        @param {L.Map} map - Leaflet map to be used for this method\n        @param {Array<L.ILayer>} layers - Set of layers\n        @param {L.LatLng} latlng - The position to search\n        @param {?Number} [n=layers.length] - the expected number of output layers.\n        @returns {Array<object>} an array of objects ``{layer, latlng, distance}`` or ``null`` if the input is invalid (empty list or negative n)\n    */\n    nClosestLayers: function (map, layers, latlng, n) {\n        n = typeof n === 'number' ? n : layers.length;\n\n        if (n < 1 || layers.length < 1) {\n            return null;\n        }\n\n        var results = [];\n        var distance, ll;\n\n        for (var i = 0, m = layers.length; i < m; i++) {\n            var layer = layers[i];\n            if (layer instanceof L.LayerGroup) {\n                // recursive\n                var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);\n                results.push(subResult);\n            } else {\n                // Single dimension, snap on points, else snap on closest\n                if (typeof layer.getLatLng == 'function') {\n                    ll = layer.getLatLng();\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                }\n                else {\n                    ll = L.GeometryUtil.closest(map, layer, latlng);\n                    if (ll) distance = ll.distance;  // Can return null if layer has no points.\n                }\n                results.push({layer: layer, latlng: ll, distance: distance});\n            }\n        }\n\n        results.sort(function(a, b) {\n            return a.distance - b.distance;\n        });\n\n        if (results.length > n) {\n            return results.slice(0, n);\n        } else  {\n            return results;\n        }\n    },\n\n    /**\n     * Returns all layers within a radius of the given position, in an ascending order of distance.\n       @param {L.Map} map Leaflet map to be used for this method\n       @param {Array<ILayer>} layers - A list of layers.\n       @param {L.LatLng} latlng - The position to search\n       @param {?Number} [radius=Infinity] - Search radius in pixels\n       @return {object[]} an array of objects including layer within the radius, closest latlng, and distance\n     */\n    layersWithin: function(map, layers, latlng, radius) {\n      radius = typeof radius == 'number' ? radius : Infinity;\n\n      var results = [];\n      var ll = null;\n      var distance = 0;\n\n      for (var i = 0, n = layers.length; i < n; i++) {\n        var layer = layers[i];\n\n        if (typeof layer.getLatLng == 'function') {\n            ll = layer.getLatLng();\n            distance = L.GeometryUtil.distance(map, latlng, ll);\n        }\n        else {\n            ll = L.GeometryUtil.closest(map, layer, latlng);\n            if (ll) distance = ll.distance;  // Can return null if layer has no points.\n        }\n\n        if (ll && distance < radius) {\n            results.push({layer: layer, latlng: ll, distance: distance});\n        }\n      }\n\n      var sortedResults = results.sort(function(a, b) {\n          return a.distance - b.distance;\n      });\n\n      return sortedResults;\n    },\n\n    /**\n        Returns the closest position from specified {LatLng} among specified layers,\n        with a maximum tolerance in pixels, providing snapping behaviour.\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<ILayer>} layers - A list of layers to snap on.\n        @param {L.LatLng} latlng - The position to snap\n        @param {?Number} [tolerance=Infinity] - Maximum number of pixels.\n        @param {?boolean} [withVertices=true] - Snap to layers vertices or segment points (not only vertex)\n        @returns {object} with snapped {LatLng} and snapped {Layer} or null if tolerance exceeded.\n    */\n    closestLayerSnap: function (map, layers, latlng, tolerance, withVertices) {\n        tolerance = typeof tolerance == 'number' ? tolerance : Infinity;\n        withVertices = typeof withVertices == 'boolean' ? withVertices : true;\n\n        var result = L.GeometryUtil.closestLayer(map, layers, latlng);\n        if (!result || result.distance > tolerance)\n            return null;\n\n        // If snapped layer is linear, try to snap on vertices (extremities and middle points)\n        if (withVertices && typeof result.layer.getLatLngs == 'function') {\n            var closest = L.GeometryUtil.closest(map, result.layer, result.latlng, true);\n            if (closest.distance < tolerance) {\n                result.latlng = closest;\n                result.distance = L.GeometryUtil.distance(map, closest, latlng);\n            }\n        }\n        return result;\n    },\n\n    /**\n        Returns the Point located on a segment at the specified ratio of the segment length.\n        @param {L.Point} pA coordinates of point A\n        @param {L.Point} pB coordinates of point B\n        @param {Number} the length ratio, expressed as a decimal between 0 and 1, inclusive.\n        @returns {L.Point} the interpolated point.\n    */\n    interpolateOnPointSegment: function (pA, pB, ratio) {\n        return L.point(\n            (pA.x * (1 - ratio)) + (ratio * pB.x),\n            (pA.y * (1 - ratio)) + (ratio * pB.y)\n        );\n    },\n\n    /**\n        Returns the coordinate of the point located on a line at the specified ratio of the line length.\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.LatLng>|L.PolyLine} latlngs Set of geographical points\n        @param {Number} ratio the length ratio, expressed as a decimal between 0 and 1, inclusive\n        @returns {Object} an object with latLng ({LatLng}) and predecessor ({Number}), the index of the preceding vertex in the Polyline\n        (-1 if the interpolated point is the first vertex)\n    */\n    interpolateOnLine: function (map, latLngs, ratio) {\n        latLngs = (latLngs instanceof L.Polyline) ? latLngs.getLatLngs() : latLngs;\n        var n = latLngs.length;\n        if (n < 2) {\n            return null;\n        }\n\n        // ensure the ratio is between 0 and 1;\n        ratio = Math.max(Math.min(ratio, 1), 0);\n\n        if (ratio === 0) {\n            return {\n                latLng: latLngs[0] instanceof L.LatLng ? latLngs[0] : L.latLng(latLngs[0]),\n                predecessor: -1\n            };\n        }\n        if (ratio == 1) {\n            return {\n                latLng: latLngs[latLngs.length -1] instanceof L.LatLng ? latLngs[latLngs.length -1] : L.latLng(latLngs[latLngs.length -1]),\n                predecessor: latLngs.length - 2\n            };\n        }\n\n        // project the LatLngs as Points,\n        // and compute total planar length of the line at max precision\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity)\n            maxzoom = map.getZoom();\n        var pts = [];\n        var lineLength = 0;\n        for(var i = 0; i < n; i++) {\n            pts[i] = map.project(latLngs[i], maxzoom);\n            if(i > 0)\n              lineLength += pts[i-1].distanceTo(pts[i]);\n        }\n\n        var ratioDist = lineLength * ratio;\n\n\t\t// follow the line segments [ab], adding lengths,\n        // until we find the segment where the points should lie on\n\t\tvar cumulativeDistanceToA = 0, cumulativeDistanceToB = 0;\n\t\tfor (var i = 0; cumulativeDistanceToB < ratioDist; i++) {\n\t\t\tvar pointA = pts[i], pointB = pts[i+1];\n\n\t\t\tcumulativeDistanceToA = cumulativeDistanceToB;\n\t\t\tcumulativeDistanceToB += pointA.distanceTo(pointB);\n\t\t}\n\t\t\n\t\tif (pointA == undefined && pointB == undefined) { // Happens when line has no length\n\t\t\tvar pointA = pts[0], pointB = pts[1], i = 1;\n\t\t}\n\n\t\t// compute the ratio relative to the segment [ab]\n\t\tvar segmentRatio = ((cumulativeDistanceToB - cumulativeDistanceToA) !== 0) ? ((ratioDist - cumulativeDistanceToA) / (cumulativeDistanceToB - cumulativeDistanceToA)) : 0;\n\t\tvar interpolatedPoint = L.GeometryUtil.interpolateOnPointSegment(pointA, pointB, segmentRatio);\n\t\treturn {\n\t\t\tlatLng: map.unproject(interpolatedPoint, maxzoom),\n\t\t\tpredecessor: i-1\n\t\t};\n    },\n\n    /**\n        Returns a float between 0 and 1 representing the location of the\n        closest point on polyline to the given latlng, as a fraction of total line length.\n        (opposite of L.GeometryUtil.interpolateOnLine())\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.PolyLine} polyline Polyline on which the latlng will be search\n        @param {L.LatLng} latlng The position to search\n        @returns {Number} Float between 0 and 1\n    */\n    locateOnLine: function (map, polyline, latlng) {\n        var latlngs = polyline.getLatLngs();\n        if (latlng.equals(latlngs[0]))\n            return 0.0;\n        if (latlng.equals(latlngs[latlngs.length-1]))\n            return 1.0;\n\n        var point = L.GeometryUtil.closest(map, polyline, latlng, false),\n            lengths = L.GeometryUtil.accumulatedLengths(latlngs),\n            total_length = lengths[lengths.length-1],\n            portion = 0,\n            found = false;\n        for (var i=0, n = latlngs.length-1; i < n; i++) {\n            var l1 = latlngs[i],\n                l2 = latlngs[i+1];\n            portion = lengths[i];\n            if (L.GeometryUtil.belongsSegment(point, l1, l2, 0.001)) {\n                portion += l1.distanceTo(point);\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            throw \"Could not interpolate \" + latlng.toString() + \" within \" + polyline.toString();\n        }\n        return portion / total_length;\n    },\n\n    /**\n        Returns a clone with reversed coordinates.\n        @param {L.PolyLine} polyline polyline to reverse\n        @returns {L.PolyLine} polyline reversed\n    */\n    reverse: function (polyline) {\n        return L.polyline(polyline.getLatLngs().slice(0).reverse());\n    },\n\n    /**\n        Returns a sub-part of the polyline, from start to end.\n        If start is superior to end, returns extraction from inverted line.\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.PolyLine} polyline Polyline on which will be extracted the sub-part\n        @param {Number} start ratio, expressed as a decimal between 0 and 1, inclusive\n        @param {Number} end ratio, expressed as a decimal between 0 and 1, inclusive\n        @returns {Array<L.LatLng>} new polyline\n     */\n    extract: function (map, polyline, start, end) {\n        if (start > end) {\n            return L.GeometryUtil.extract(map, L.GeometryUtil.reverse(polyline), 1.0-start, 1.0-end);\n        }\n\n        // Bound start and end to [0-1]\n        start = Math.max(Math.min(start, 1), 0);\n        end = Math.max(Math.min(end, 1), 0);\n\n        var latlngs = polyline.getLatLngs(),\n            startpoint = L.GeometryUtil.interpolateOnLine(map, polyline, start),\n            endpoint = L.GeometryUtil.interpolateOnLine(map, polyline, end);\n        // Return single point if start == end\n        if (start == end) {\n            var point = L.GeometryUtil.interpolateOnLine(map, polyline, end);\n            return [point.latLng];\n        }\n        // Array.slice() works indexes at 0\n        if (startpoint.predecessor == -1)\n            startpoint.predecessor = 0;\n        if (endpoint.predecessor == -1)\n            endpoint.predecessor = 0;\n        var result = latlngs.slice(startpoint.predecessor+1, endpoint.predecessor+1);\n        result.unshift(startpoint.latLng);\n        result.push(endpoint.latLng);\n        return result;\n    },\n\n    /**\n        Returns true if first polyline ends where other second starts.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    isBefore: function (polyline, other) {\n        if (!other) return false;\n        var lla = polyline.getLatLngs(),\n            llb = other.getLatLngs();\n        return (lla[lla.length-1]).equals(llb[0]);\n    },\n\n    /**\n        Returns true if first polyline starts where second ends.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    isAfter: function (polyline, other) {\n        if (!other) return false;\n        var lla = polyline.getLatLngs(),\n            llb = other.getLatLngs();\n        return (lla[0]).equals(llb[llb.length-1]);\n    },\n\n    /**\n        Returns true if first polyline starts where second ends or start.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    startsAtExtremity: function (polyline, other) {\n        if (!other) return false;\n        var lla = polyline.getLatLngs(),\n            llb = other.getLatLngs(),\n            start = lla[0];\n        return start.equals(llb[0]) || start.equals(llb[llb.length-1]);\n    },\n\n    /**\n        Returns horizontal angle in degres between two points.\n        @param {L.Point} a Coordinates of point A\n        @param {L.Point} b Coordinates of point B\n        @returns {Number} horizontal angle\n     */\n    computeAngle: function(a, b) {\n        return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI);\n    },\n\n    /**\n       Returns slope (Ax+B) between two points.\n        @param {L.Point} a Coordinates of point A\n        @param {L.Point} b Coordinates of point B\n        @returns {Object} with ``a`` and ``b`` properties.\n     */\n    computeSlope: function(a, b) {\n        var s = (b.y - a.y) / (b.x - a.x),\n            o = a.y - (s * a.x);\n        return {'a': s, 'b': o};\n    },\n\n    /**\n       Returns LatLng of rotated point around specified LatLng center.\n        @param {L.LatLng} latlngPoint: point to rotate\n        @param {double} angleDeg: angle to rotate in degrees\n        @param {L.LatLng} latlngCenter: center of rotation\n        @returns {L.LatLng} rotated point\n     */\n    rotatePoint: function(map, latlngPoint, angleDeg, latlngCenter) {\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity)\n            maxzoom = map.getZoom();\n        var angleRad = angleDeg*Math.PI/180,\n            pPoint = map.project(latlngPoint, maxzoom),\n            pCenter = map.project(latlngCenter, maxzoom),\n            x2 = Math.cos(angleRad)*(pPoint.x-pCenter.x) - Math.sin(angleRad)*(pPoint.y-pCenter.y) + pCenter.x,\n            y2 = Math.sin(angleRad)*(pPoint.x-pCenter.x) + Math.cos(angleRad)*(pPoint.y-pCenter.y) + pCenter.y;\n        return map.unproject(new L.Point(x2,y2), maxzoom);\n    },\n\n    /**\n       Returns the bearing in degrees clockwise from north (0 degrees)\n       from the first L.LatLng to the second, at the first LatLng\n       @param {L.LatLng} latlng1: origin point of the bearing\n       @param {L.LatLng} latlng2: destination point of the bearing\n       @returns {float} degrees clockwise from north.\n    */\n    bearing: function(latlng1, latlng2) {\n        var rad = Math.PI / 180,\n            lat1 = latlng1.lat * rad,\n            lat2 = latlng2.lat * rad,\n            lon1 = latlng1.lng * rad,\n            lon2 = latlng2.lng * rad,\n            y = Math.sin(lon2 - lon1) * Math.cos(lat2),\n            x = Math.cos(lat1) * Math.sin(lat2) -\n                Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n        var bearing = ((Math.atan2(y, x) * 180 / Math.PI) + 360) % 360;\n        return bearing >= 180 ? bearing-360 : bearing;\n    },\n\n    /**\n       Returns the point that is a distance and heading away from\n       the given origin point.\n       @param {L.LatLng} latlng: origin point\n       @param {float} heading: heading in degrees, clockwise from 0 degrees north.\n       @param {float} distance: distance in meters\n       @returns {L.latLng} the destination point.\n       Many thanks to Chris Veness at http://www.movable-type.co.uk/scripts/latlong.html\n       for a great reference and examples.\n    */\n    destination: function(latlng, heading, distance) {\n        heading = (heading + 360) % 360;\n        var rad = Math.PI / 180,\n            radInv = 180 / Math.PI,\n            R = 6378137, // approximation of Earth's radius\n            lon1 = latlng.lng * rad,\n            lat1 = latlng.lat * rad,\n            rheading = heading * rad,\n            sinLat1 = Math.sin(lat1),\n            cosLat1 = Math.cos(lat1),\n            cosDistR = Math.cos(distance / R),\n            sinDistR = Math.sin(distance / R),\n            lat2 = Math.asin(sinLat1 * cosDistR + cosLat1 *\n                sinDistR * Math.cos(rheading)),\n            lon2 = lon1 + Math.atan2(Math.sin(rheading) * sinDistR *\n                cosLat1, cosDistR - sinLat1 * Math.sin(lat2));\n        lon2 = lon2 * radInv;\n        lon2 = lon2 > 180 ? lon2 - 360 : lon2 < -180 ? lon2 + 360 : lon2;\n        return L.latLng([lat2 * radInv, lon2]);\n    },\n\n    /**\n       Returns the the angle of the given segment and the Equator in degrees,\n       clockwise from 0 degrees north.\n       @param {L.Map} map: Leaflet map to be used for this method\n       @param {L.LatLng} latlngA: geographical point A of the segment\n       @param {L.LatLng} latlngB: geographical point B of the segment\n       @returns {Float} the angle in degrees.\n    */\n    angle: function(map, latlngA, latlngB) {\n      var pointA = map.latLngToContainerPoint(latlngA),\n          pointB = map.latLngToContainerPoint(latlngB),\n          angleDeg = Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI + 90;\n      angleDeg += angleDeg < 0 ? 360 : 0;\n      return angleDeg;\n    },\n\n    /**\n       Returns a point snaps on the segment and heading away from the given origin point a distance.\n       @param {L.Map} map: Leaflet map to be used for this method\n       @param {L.LatLng} latlngA: geographical point A of the segment\n       @param {L.LatLng} latlngB: geographical point B of the segment\n       @param {float} distance: distance in meters\n       @returns {L.latLng} the destination point.\n    */\n    destinationOnSegment: function(map, latlngA, latlngB, distance) {\n      var angleDeg = L.GeometryUtil.angle(map, latlngA, latlngB),\n          latlng = L.GeometryUtil.destination(latlngA, angleDeg, distance);\n      return L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\n    },\n});\n\nreturn L.GeometryUtil;\n\n}));\n"]},"metadata":{},"sourceType":"script"}